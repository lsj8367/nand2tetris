# 불 논리

## NAND 게이트

Nand 게이트는 유니버셜 로직 게이트라고도 부르는데

이 게이트 하나만으로 모든 바이너리 동작을 제어할 수가 있다.

Nand게이트는 다음과 같은 불 함수를 계산한다.

| a | b | Nand(a, b) |
|:----:|----|:----:|
|0|1|0|
|0|1|1|
|1|0|1|
|1|1|0|

## 기본 논리 게이트

### Not

단일 입력 Not게이트 `Converter`라고 불리며 input값의

반대값으로 Output을 내준다.

| in | out |
|:----:|:----:|
|0|1|
|1|0|

### And

And는 곱연산으로서, 입력 값이 둘다 1일 경우에만 1을 출력해준다.

| a | b | And(a, b) |
|:----:|:----:|:----:|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

### Or

Or는 합연산으로, 입력값 2개중 1개가 1이라면 1을 출력해준다.

| a | b | Or(a, b) |
|:----:|:----:|:----:|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

### Xor

`배타적 논리합` 이라고 불리며, 두 입력값이 서로 다를 경우 1

그렇지 않으면 0을 출력한다.

| a | b | Xor(a, b) |
|:----:|:----:|:----:|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

### 멀티플렉서(Multiplexer)

멀티플렉서는 3입력 게이트로 selector 비트를 이용하여

나머지 두개 데이터 비트 입력중 하나를 선택.

| a | b | sel | Mux(a, b) |
|:----:|:----:|:----:|:----:|
|0|0|0|0|
|0|1|0|0|
|1|0|0|1|
|1|1|0|1|
|0|0|1|0|
|0|1|1|1|
|1|0|1|0|
|1|1|1|1|

![image](https://user-images.githubusercontent.com/74235102/133886757-6efeda64-8309-4a89-a8b2-48e384046fe5.png)

### 디멀티플렉서

이름만봐도 멀티플렉서의 정반대 기능을 수행한다고 알 수 있다.

디멀티플렉서는 선택한 비트에 따라 출력선 중 하나를 선택해 입력 신호를 보낸다.

| sel | a | b |
|:----:|:----:|:----:|
|0|in|0|
|1|0|in|

![image (1)](https://user-images.githubusercontent.com/74235102/133886762-2ae5cd2f-50cb-4629-8670-93fc2c475a81.png)

## 멀티비트

멀티비트는 `버스`라는 멀티배열에 대한 연산을 수행하게 되어있다.

이 연산들은 쭉 같은 논리연산을 나열하여 비트의 쌍마다 연산을 수행해주는 것이다.

여기서는 16비트에 대한 연산을 진행했다.

AND 연산으로 예를 들어보겠다.

원래 하나의 비트 XY에 대하여 결과값을 AND(X,Y) 했던것을 16개를 동시에 진행한다고 

생각하면 된다.

아래의 모든 예시는 전부 `16비트` 연산으로 이루어져있다.

### AND16

|X0 ~ X15|Y0 ~ Y15|AND16(X,Y)|
|:-:|:-:|:-:|
|0000000000000000|0000000000000000|0000000000000000|
|0000000000000000|1111111111111111|0000000000000000|
|1111111111111111|0000000000000000|0000000000000000|
|1111111111111111|1111111111111111|1111111111111111|

기본 게이트의 연산과 같은데 갯수만 늘어난 것이므로 설명은 생략하도록 하겠다.

### OR16

|X0 ~ X15|Y0 ~ Y15|OR16(X,Y)|
|:-:|:-:|:-:|
|0000000000000000|0000000000000000|0000000000000000|
|0000000000000000|1111111111111111|1111111111111111|
|1111111111111111|0000000000000000|1111111111111111|
|1111111111111111|1111111111111111|1111111111111111|

### NOT16
|IN|NOT16(X,Y)|
|:-:|:-:|
|0000000000000000|1111111111111111|
|1111111111111111|0000000000000000|

### MUX16 멀티플렉서

|X|Y|SEL|MUX16(X,Y,SEL)|
|:-:|:-:|:-:|:-:|
|0000000000000000|0000000000000000|   0   |0000000000000000|
|0000000000000000|0000000000000000|   1   |0000000000000000|
|0000000000000000|1111111111111111|   0   |0000000000000000|
|0000000000000000|1111111111111111|   1   |1111111111111111|
|1111111111111111|0000000000000000|   0   |1111111111111111|
|1111111111111111|0000000000000000|   1   |0000000000000000|
|1111111111111111|1111111111111111|   0   |1111111111111111|
|1111111111111111|1111111111111111|   1   |1111111111111111|

## 다입력

입력이 여러개인 다입력 게이트이다.

다입력에는 다입력/멀티비트 도 같이 묶어서 정리하겠다.

### Or8Way

![image](https://user-images.githubusercontent.com/74235102/134760695-f75b3b92-7e9c-4b90-ad33-53c073ab0b06.png)

Or8Way의 논리게이트 인터페이스는 다음과 같다.

### Mux4Way

![image](https://user-images.githubusercontent.com/74235102/134760740-23e3880f-d73b-4243-836f-77f096ea1818.png)

이것의 멀티비트라고 한다면

이 같은 그림이 16개가 같이 수행된다고 생각하면 된다.

셀렉터가 2개이기 때문에

|A|B|C|D|SEL[2]|MUX16(X,Y,SEL)|
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  00  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  01  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  10  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  11  | 0000000000000000 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 |  00  | 0001001000110100 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 |  01  | 1001100001110110 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 |  10  | 1010101010101010 |
| 0001001000110100 | 1001100001110110 | 1010101010101010 | 0101010101010101 |  11  | 0101010101010101 |

sel 0번째로 a,b 그리고 c,d 를 연산 한후에
나온 결과값 o1, o2를 sel 1번째로 연산하여 결과값을 출력해주는 구조이다.

### Mux8Way
![image](https://user-images.githubusercontent.com/74235102/134760842-f18a1b90-83e1-4d4d-a311-2d8a8351f183.png)

4Way의 구조를 2개로 만들어서 결과값을 도출해주는 8입력 멀티플렉서이다.

|a|b|c|d|e|f|g|h|sel|out|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  000  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  001  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  010  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  011  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  100  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  101  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  110  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  111  | 0000000000000000 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  000  | 0001001000110100 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  001  | 0010001101000101 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  010  | 0011010001010110 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  011  | 0100010101100111 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  100  | 0101011001111000 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  101  | 0110011110001001 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  110  | 0111100010011010 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  111  | 1000100110101011 |

### DMux4Way

반대인 디 멀티플렉서이다. 

여기부터는 실습에서도 멀티비트는 하지 않았기에 하나만 쓰도록 하겠다.

이건 입력을 1개를 받아서 4개의 결과값을 도출해주는 정반대 플렉서이다.

![image](https://user-images.githubusercontent.com/74235102/134761100-e1a961b8-80e0-45bc-a8da-9d4ff7c8bd93.png)


| in  | sel  |  a  |  b  |  c  |  d  |
|:-:|:-:|:-:|:-:|:-:|:-:|
|  0  |  00  |  0  |  0  |  0  |  0  |
|  0  |  01  |  0  |  0  |  0  |  0  |
|  0  |  10  |  0  |  0  |  0  |  0  |
|  0  |  11  |  0  |  0  |  0  |  0  |
|  1  |  00  |  1  |  0  |  0  |  0  |
|  1  |  01  |  0  |  1  |  0  |  0  |
|  1  |  10  |  0  |  0  |  1  |  0  |
|  1  |  11  |  0  |  0  |  0  |  1  |

### DMux8Way

![image](https://user-images.githubusercontent.com/74235102/134761156-dcd521cf-d90d-44fb-8708-6fa9d8c3a92a.png)

이것도 `Mux8Way`와 반대의 특성을 가지고 있으며 4Way 2개가 붙어진 것이다.

| in  |  sel  |  a  |  b  |  c  |  d  |  e  |  f  |  g  |  h  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  0  |  000  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  001  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  010  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  011  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  100  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  101  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  110  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  111  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  000  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  001  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  010  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |
|  1  |  011  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |
|  1  |  100  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |
|  1  |  101  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |
|  1  |  110  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |
|  1  |  111  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |

## 정리
이렇게 1장 `불 논리`가 끝이났다.

처음 구현을 시작했을 때에는 `NAND` 게이트로 쭉쭉 구현을 진행했는데

특징이라고 한다면 컴파일 자체가 가령 Or를 구현해야 한다고 치면

Or만 써서 바로 구현할 수가 없게 해놨다.

이런 함수를 하나씩 쓰려면 그 전의 동작을 알게끔 한것인가?

하는 생각이 들었다.

그리고 마지막으로는 결국 구현이 다 되어서 `BUILTIN`이라는 기능으로

`tools` - `builtInChips` 안의 자바 클래스파일들 이 있으면

해당 기능을 사용할 수 있었다.

마지막으로는 그것으로 구현해두고 나머지는 주석처리를 진행했다.

이진수를 다루면서 완전 밑바닥을 체험하니 재밌기도 하고 어렵기도 했다.